-- File: rgb2ycbcr.vhd
-- Generated by MyHDL 0.9.0
-- Date: Thu Jan 21 14:21:38 2016


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_090.all;

entity rgb2ycbcr is
    port (
        enable_out: out std_logic;
        enable_in: in std_logic;
        clk: in std_logic;
        reset: in std_logic;
        ycbcr_y: out unsigned(7 downto 0);
        ycbcr_cb: out unsigned(7 downto 0);
        ycbcr_cr: out unsigned(7 downto 0);
        rgb_blue: in unsigned(7 downto 0);
        rgb_green: in unsigned(7 downto 0);
        rgb_red: in unsigned(7 downto 0)
    );
end entity rgb2ycbcr;
-- A RGB to YCbCr converter with reset.
-- 
-- I/O pins:
-- --------
-- y           : output 8-bit unsigned value in range of 0-127
-- cb          : output 8-bit unsigned value in range of 0-128
-- cr          : output 8-bit unsigned value in range of 0-128
-- enable_out  : output True when output is available
-- r           : input 8-bit unsigned value in range of 0-255
-- g           : input 8-bit unsigned value in range of 0-255
-- b           : input 8-bit unsigned value in range of 0-255
-- enable_in   : input True when input is available
-- clk         : input clock boolean signal
-- reset       : input reset boolean signal

architecture MyHDL of rgb2ycbcr is


constant ACTIVE_HIGH: integer := 1;
constant INACTIVE_LOW: integer := 0;



signal Y2_s: signed (14 downto 0);
signal Y3_s: signed (14 downto 0);
signal Y1_s: signed (14 downto 0);
signal Cr1_s: signed (14 downto 0);
signal G_s: signed (8 downto 0);
signal Cr_sum: signed (23 downto 0);
signal Cr2_s: signed (14 downto 0);
signal offset_y: signed (23 downto 0);
signal Cr3_s: signed (14 downto 0);
signal Cb_sum: signed (23 downto 0);
signal R_s: signed (8 downto 0);
signal offset_cr: signed (23 downto 0);
signal Cb1_s: signed (14 downto 0);
signal Y_sum: signed (23 downto 0);
signal Cb2_s: signed (14 downto 0);
signal offset_cb: signed (23 downto 0);
signal Cb3_s: signed (14 downto 0);
signal B_s: signed (8 downto 0);
type t_array_Cb_reg is array(0 to 3-1) of signed (23 downto 0);
signal Cb_reg: t_array_Cb_reg;
type t_array_Cr_reg is array(0 to 3-1) of signed (23 downto 0);
signal Cr_reg: t_array_Cr_reg;
type t_array_Y_reg is array(0 to 3-1) of signed (23 downto 0);
signal Y_reg: t_array_Y_reg;

begin


Y2_s <= to_signed(9617, 15);
Y3_s <= to_signed(1868, 15);
Y1_s <= to_signed(4914, 15);
Cr1_s <= to_signed(8192, 15);
Cr2_s <= to_signed(-6860, 15);
offset_y <= to_signed(0, 24);
Cr3_s <= to_signed(-1332, 15);
offset_cr <= to_signed(2097152, 24);
Cb1_s <= to_signed(-2764, 15);
Cb2_s <= to_signed(-5428, 15);
offset_cb <= to_signed(2097152, 24);
Cb3_s <= to_signed(8192, 15);



RGB2YCBCR_LOGIC: process (clk, reset) is
begin
    if (reset = '0') then
        Y_sum <= to_signed(0, 24);
        Cb_sum <= to_signed(0, 24);
        ycbcr_cb <= to_unsigned(0, 8);
        enable_out <= '0';
        Cr_reg(0) <= to_signed(0, 24);
        Cr_reg(1) <= to_signed(0, 24);
        Cr_reg(2) <= to_signed(0, 24);
        Y_reg(0) <= to_signed(0, 24);
        Y_reg(1) <= to_signed(0, 24);
        Y_reg(2) <= to_signed(0, 24);
        Cr_sum <= to_signed(0, 24);
        ycbcr_cr <= to_unsigned(0, 8);
        Cb_reg(0) <= to_signed(0, 24);
        Cb_reg(1) <= to_signed(0, 24);
        Cb_reg(2) <= to_signed(0, 24);
        ycbcr_y <= to_unsigned(0, 8);
    elsif rising_edge(clk) then
        enable_out <= '0';
        if (enable_in = '1') then
            Y_reg(0) <= (R_s * Y1_s);
            Y_reg(1) <= (G_s * Y2_s);
            Y_reg(2) <= (B_s * Y3_s);
            Cb_reg(0) <= (R_s * Cb1_s);
            Cb_reg(1) <= (G_s * Cb2_s);
            Cb_reg(2) <= (B_s * Cb3_s);
            Cr_reg(0) <= (R_s * Cr1_s);
            Cr_reg(1) <= (G_s * Cr2_s);
            Cr_reg(2) <= (B_s * Cr3_s);
            Y_sum <= (((Y_reg(0) + Y_reg(1)) + Y_reg(2)) + offset_y);
            Cb_sum <= (((Cb_reg(0) + Cb_reg(1)) + Cb_reg(2)) + offset_cb);
            Cr_sum <= (((Cr_reg(0) + Cr_reg(1)) + Cr_reg(2)) + offset_cr);
            ycbcr_y <= unsigned(Y_sum(22-1 downto 14));
            ycbcr_cb <= unsigned(Cb_sum(22-1 downto 14));
            ycbcr_cr <= unsigned(Cr_sum(22-1 downto 14));
        end if;
        enable_out <= '1';
    end if;
end process RGB2YCBCR_LOGIC;



R_s <= signed(resize(rgb_red, 9));
G_s <= signed(resize(rgb_green, 9));
B_s <= signed(resize(rgb_blue, 9));

end architecture MyHDL;
