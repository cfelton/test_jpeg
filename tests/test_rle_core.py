"""The above testbench tests rle core functioning and conversion"""

from myhdl import StopSimulation
from myhdl import block
from myhdl import ResetSignal, Signal, instance
from myhdl.conversion import verify

from jpegenc.subblocks.rle.rlecore import DataStream, rle, Component
from jpegenc.subblocks.rle.rlecore import RLESymbols, RLEConfig

from jpegenc.testing import run_testbench
from jpegenc.testing import (toggle_signal, clock_driver,
                             reset_on_start, pulse_reset)
from jpegenc.testing import rle_inputs


def block_process(
        clock, block_in, input_interface,
        output_interface, control_unit, color, max_count):
    """
    This block sends data into rlecore and prints the output

    block_in         : input data block
    input_interface  : datastream bus interface
    output_interface : bufferdata bus interface
    control_unit     : rleconfig interface
    max_count        : depth of fifo
    color            : color component to be processes

    """

    assert isinstance(input_interface, DataStream)
    assert isinstance(output_interface, RLESymbols)
    assert isinstance(control_unit, RLEConfig)

    # select one among y1,y2, cb or cr
    control_unit.color_component.next = color

    # wait till start signal asserts
    yield toggle_signal(control_unit.start, clock)

    # read input from the block
    input_interface.data_in.next = block_in[input_interface.read_addr]
    yield clock.posedge

    # read more inputs
    while input_interface.read_addr != max_count:
        input_interface.data_in.next = block_in[input_interface.read_addr]
        yield clock.posedge

        # print output
        if output_interface.dovalid:
            print("amplitude = %d runlength = %d size = %d" % (
                output_interface.amplitude,
                output_interface.runlength, output_interface.size))

    input_interface.data_in.next = block_in[input_interface.read_addr]

    yield clock.posedge
    if output_interface.dovalid:
        print("amplitude = %d runlength = %d size = %d" % (
            output_interface.amplitude,
            output_interface.runlength, output_interface.size))

    # extra clocks for all the inputs to process

    yield clock.posedge
    if output_interface.dovalid:
        print("amplitude = %d runlength = %d size = %d" % (
            output_interface.amplitude,
            output_interface.runlength, output_interface.size))

    yield clock.posedge
    if output_interface.dovalid:
        print("amplitude = %d runlength = %d size = %d" % (
            output_interface.amplitude,
            output_interface.runlength, output_interface.size))

    yield clock.posedge
    if output_interface.dovalid:
        print("amplitude = %d runlength = %d size = %d" % (
            output_interface.amplitude,
            output_interface.runlength, output_interface.size))

    yield clock.posedge
    if output_interface.dovalid:
        print("amplitude = %d runlength = %d size = %d" % (
            output_interface.amplitude,
            output_interface.runlength, output_interface.size))


def test_rle_core():
    """functionality of rle core tested here"""

    # instantiation of clock and reset
    clock = Signal(bool(0))
    reset = ResetSignal(0, active=1, async=True)

    # instantiation of component select block
    component = Component()

    # input data width into the rlecore
    width_data = 12

    # address data width
    width_addr = 6

    # number of bits required to store amplitude
    width_size = width_data.bit_length()

    # maximum counter value
    max_addr_cnt = (2**width_addr) - 1

    # maximum width of the runlength value
    width_runlength = 4

    # input bus to the rlecore
    datastream = DataStream(width_data, width_addr)
    assert isinstance(datastream, DataStream)

    # symbols generated by the rle core
    rlesymbols = RLESymbols(width_data, width_size, width_runlength)
    assert isinstance(rlesymbols, RLESymbols)

    # selects the color component, manages address values
    rleconfig = RLEConfig()
    assert isinstance(rleconfig, RLEConfig)

    @block
    def bench_rle_core():
        """The RLE Core is tested in this block"""

        # instantiation of the rle core
        inst = rle(
            clock, reset, datastream, rlesymbols, rleconfig
            )

        # clock instantiation
        inst_clock = clock_driver(clock)

        @instance
        def tbstim():
            """Test inputs given here"""

            # reset before sending data
            yield pulse_reset(reset, clock)

            # components of type y1 or y2 processed
            yield block_process(
                clock, rle_inputs.red_pixels_1,
                datastream,
                rlesymbols,
                rleconfig, component.y1_space, max_count=max_addr_cnt
                )

            print("======================")

            # components of type y1 or y2 processed
            yield block_process(
                clock, rle_inputs.red_pixels_2,
                datastream,
                rlesymbols,
                rleconfig, component.y2_space, max_count=max_addr_cnt
                )

            print("=====================")

            # components of type cb processes
            yield block_process(
                clock, rle_inputs.green_pixels_1,
                datastream,
                rlesymbols,
                rleconfig, component.cb_space, max_count=max_addr_cnt
                )

            print("=====================")

            # components od type cb processed
            yield block_process(
                clock, rle_inputs.green_pixels_2,
                datastream,
                rlesymbols,
                rleconfig, component.cb_space, max_count=max_addr_cnt
                )

            print("=====================")

            # components of type cr processed
            yield block_process(
                clock, rle_inputs.blue_pixels_1,
                datastream,
                rlesymbols,
                rleconfig, component.cr_space, max_count=max_addr_cnt
                )

            print("=====================")

            # components of type cr processed
            yield block_process(
                clock, rle_inputs.blue_pixels_2,
                datastream,
                rlesymbols,
                rleconfig, component.cr_space, max_count=max_addr_cnt
                )

            print("=====================")

            # start of new frame asserts
            rleconfig.sof.next = True
            yield clock.posedge

            raise StopSimulation

        return tbstim, inst_clock, inst

    run_testbench(bench_rle_core)


def test_rle_conversion():
    """This module is used for conversion purpose"""

    # clock and reset instantiation
    clock = Signal(bool(0))
    reset = ResetSignal(0, active=1, async=True)

    # width of the input data
    width_data = 12

    # width of the address bud
    width_addr = 6

    # number of bits to store ouput
    width_size = width_data.bit_length()

    # width of the maximum runlength value
    width_runlength = 4

    # input datastream
    datastream = DataStream(width_data, width_addr)
    assert isinstance(datastream, DataStream)

    # symbols generated by the rle core
    rlesymbols = RLESymbols(width_data, width_size, width_runlength)
    assert isinstance(rlesymbols, RLESymbols)

    # selects the color component, manages address values
    rleconfig = RLEConfig()
    assert isinstance(rleconfig, RLEConfig)

    @block
    def bench_rle_core():
        """The conversion module for rle core"""
        inst = rle(
            clock, reset,
            datastream, rlesymbols, rleconfig
            )
        inst_clock = clock_driver(clock)
        inst_reset = reset_on_start(reset, clock)

        @instance
        def tbstim():
            """dummy inputs for conversion purpose"""
            yield clock.posedge
            print ("Conversion done!!")
            raise StopSimulation

        return tbstim, inst, inst_clock, inst_reset

    verify.simulator = 'iverilog'
    assert bench_rle_core().verify_convert() == 0
